using System.Data;
using Microsoft.Extensions.Options;
using MongoDB.Driver;
using Stix.Models;

namespace Stix.Persistence;

public class VulnerabilityDao : IVulnerabilityDao
{
    private readonly ILogger<VulnerabilityDao> _logger;

    private readonly IMongoCollection<VulnerabilityEntity> _collection;
    
    public VulnerabilityDao(IOptions<DbSettings> dbSettings, ILogger<VulnerabilityDao> logger)
    {
        _logger = logger;
        var mongoClient = new MongoClient(dbSettings.Value.ConnectionString);
        var mongoDatabase = mongoClient.GetDatabase(dbSettings.Value.DatabaseName);
        _collection = mongoDatabase.GetCollection<VulnerabilityEntity>(dbSettings.Value.CollectionName);
    }

    public async Task SaveAsync(VulnerabilityEntity vulnerabilityEntity)
    {
        try
        {
            await _collection.InsertOneAsync(vulnerabilityEntity);
        }
        catch (MongoWriteException exception)
        {
            if (exception.WriteError.Category == ServerErrorCategory.DuplicateKey)
            {
                throw new DuplicateNameException($"A vulnerability with the given id already exists: {vulnerabilityEntity.Id}.", exception);
            }
            throw;
        }
    }

    public async Task UpdateAsync(string id, VulnerabilityEntity vulnerabilityEntity)
    {
        await _collection.ReplaceOneAsync(entity => entity.Id == id, vulnerabilityEntity);
    }

    public async Task DeleteAsync(string id)
    {
        await _collection.DeleteOneAsync(entity => entity.Id == id);
    }

    public async Task<IList<VulnerabilityEntity>> ListAsync(QueryOptions queryOptions)
    {
        var query = _collection.Find(entity => true)
            .SortBy(entity => entity.Name)
            .Skip(queryOptions.Offset)
            .Limit(queryOptions.Limit);

        return await query.ToListAsync();
    }

    public async Task<VulnerabilityEntity> GetByIdAsync(string id)
    {
        var result = await _collection.Find(entity => entity.Id == id).ToListAsync();
        if (!result.Any())
        {
            throw new KeyNotFoundException($"No vulnerability found with id: {id}");
        }

        return result.First();
    }
}